<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Призраки Везенбергского квартала</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <link rel="manifest" href="manifest.json" crossorigin="use-credentials">
  
  <!-- Подключение CSS -->
  <link rel="stylesheet" href="play.css">
  
  <!-- Оптимизация загрузки иконок -->
  <link rel="icon" href="icons/icon-192x192.png" sizes="192x192" type="image/png">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <meta name="theme-color" content="#000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Призраки Везенберга">

  <!-- Предзагрузка критических ресурсов -->
  <link rel="preload" href="renpy-pre.js" as="script">
  <link rel="preload" href="renpy.js" as="script">
  <link rel="preload" href="web-presplash.jpg" as="image">
</head>

<body>
  <!-- Остальная часть HTML остается без изменений -->
  <div class="loader"></div>
  
  <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
  <div id="overlayDiv"></div>

  <img id="presplash" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='1' viewBox='0 0 1 1'%3E%3C/svg%3E" 
       data-src="web-presplash.jpg" alt="Загрузка игры...">

  <!-- Левый верхний угол - меню -->
  <div id="ContextContainer">
    <button id="ContextButton" class="icon-button" aria-label="Меню">≡</button>
    <div id="ContextMenu">
      <input id="ID_SavegamesImport" type="file" onchange="onSavegamesImport(this)" accept="application/zip" hidden>
      <a href="index.html" class="context-menu-item">Назад к играм</a>
      <button id="installMenuItem" class="context-menu-item">Инструкция для iPhone</button>
    </div>
  </div>

  <!-- Правый верхний угол - полноэкранный режим -->
  <div id="TopRightContainer">
    <button id="FullscreenButton" class="icon-button" aria-label="Полноэкранный режим">
      <img id="FullscreenIcon" src="icons/fullscreen.png" alt="Полноэкранный режим">
    </button>
  </div>

  <!-- Модальное окно для установки -->
  <div id="installModal">
    <div class="modal-content">
      <h2 class="modal-title">Инструкция для iPhone</h2>
      <p class="modal-text">Для установки приложения на главный экран:</p>
      
      <ol class="modal-text">
        <li>Нажмите кнопку "Поделиться" внизу браузера</li>
        <li>Прокрутите меню вниз и выберите "На экран «Домой»"</li>
        <li>Нажмите "Добавить" в правом верхнем углу</li>
        <li>Далее зайдите в приложение и начните играть в полноэкранном режиме</li>
      </ol>
      
      <div class="modal-buttons">
        <button class="modal-button secondary" id="closeInstallModal">Закрыть</button>
      </div>
    </div>
  </div>

  <!-- Сообщение о беззвучном режиме для iOS -->
  <div id="silentModeWarning" class="silent-warning hidden">
    <div class="silent-warning-content">
      <p>С бесшумным режимом вы не услышите музыки</p>
    </div>
  </div>

  <div id="statusDiv" class="hidden">
    <div id="statusTextDiv"></div>
    <progress id="statusProgress" value="0" max="100"></progress>
  </div>

  <div id="inputDiv" class="hidden">
    <form id="inputForm">
      <div id="inputPrompt"></div>
      <input id="inputText" type="text" autocomplete="off">
    </form>
  </div>

  <script>
    // Глобальные переменные для функций меню
    let closeContextMenu, openContextMenu;
    
    // Флаг для отслеживания пользовательского взаимодействия
    let userInteracted = false;
    
    // Основной код JavaScript остается здесь, но будет реорганизован
    // URL игры и регистрация Service Worker
    window.gameZipURL = 'game.zip';
    
    // Регистрация Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        if (!navigator.serviceWorker.controller) {
          navigator.serviceWorker.register('./service-worker.js', { 
            updateViaCache: 'all',
            scope: './'
          });
        }
      });
    }
    
    // Функция проверки, запущено ли приложение с домашнего экрана
    function isRunningInStandaloneMode() {
      return window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
    }
    
    // Функция проверки iOS устройства
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }
    
    // Функция проверки Android устройства
    function isAndroid() {
      return /Android/.test(navigator.userAgent);
    }
    
    // Управление аудио
    let audioContexts = [];
    
    // Функция возобновления аудио контекста
    function resumeAudioContext() {
      if (context && context.state !== "running") {
        context.resume().then(() => {
          console.log("AudioContext успешно возобновлен");
        }).catch((error) => {
          console.error("Ошибка при возобновлении AudioContext:", error);
        });
      }
    }
    
    // Обработчик первого взаимодействия пользователя
    function handleFirstUserInteraction() {
      if (!userInteracted) {
        userInteracted = true;
        resumeAudioContext();
        
        // Удаляем обработчики после первого взаимодействия
        document.removeEventListener('click', handleFirstUserInteraction);
        document.removeEventListener('touchstart', handleFirstUserInteraction);
        document.removeEventListener('keydown', handleFirstUserInteraction);
      }
    }
    
    function pauseAllAudio() {
      // Приостанавливаем все аудио контексты
      audioContexts.forEach(ctx => {
        if (ctx.state === 'running') {
          ctx.suspend().catch(e => console.error('Error suspending audio context:', e));
        }
      });
      
      // Также приостанавливаем HTML5 аудио элементы
      document.querySelectorAll('audio, video').forEach(media => {
        if (!media.paused) {
          media.pause();
        }
      });
    }
    
    function resumeAllAudio() {
      // Возобновляем все аудио контексты только если было пользовательское взаимодействие
      if (userInteracted) {
        audioContexts.forEach(ctx => {
          if (ctx.state === 'suspended') {
            ctx.resume().catch(e => console.error('Error resuming audio context:', e));
          }
        });
      }
    }
    
    // Переопределяем функцию queue_depth для Ren'Py
    function patchRenpyAudio() {
      if (typeof renpyAudio !== 'undefined' && renpyAudio.queue_depth) {
        // Сохраняем оригинальную функцию
        const originalQueueDepth = renpyAudio.queue_depth;
        
        // Переопределяем функцию без попытки автоматического возобновления
        renpyAudio.queue_depth = (channel) => {
          let rv = 0;
          let c = get_channel(channel);
          
          // Убрали попытку автоматического возобновления контекста
          // Теперь контекст будет возобновляться только через обработчики жестов
          
          if (c.playing !== null) {
            rv += 1;
          }
          
          if (c.queued !== null) {
            rv += 1;
          }
          
          return rv;
        };
      }
    }
    
    // Показ сообщения о беззвучном режиме на iOS
    function showSilentModeWarning() {
      const warning = document.getElementById('silentModeWarning');
      if (!warning) return;
      
      // Проверяем, не показывали ли уже сообщение в этой сессии
      if (sessionStorage.getItem('silentWarningShown')) return;
      
      warning.classList.remove('hidden');
      
      // Скрываем сообщение через 5 секунд
      const hideTimeout = setTimeout(() => {
        hideSilentModeWarning();
      }, 5000);
      
      // Скрываем при клике в любом месте
      warning.addEventListener('click', function hideOnClick() {
        clearTimeout(hideTimeout);
        hideSilentModeWarning();
        warning.removeEventListener('click', hideOnClick);
      });
      
      // Также скрываем, если пользователь открыл инструкцию
      const installMenuItem = document.getElementById('installMenuItem');
      const installModal = document.getElementById('installModal');
      if (installMenuItem && installModal) {
        installMenuItem.addEventListener('click', function hideOnInstruction() {
          clearTimeout(hideTimeout);
          hideSilentModeWarning();
          installMenuItem.removeEventListener('click', hideOnInstruction);
        });
        
        installModal.addEventListener('click', function(e) {
          if (e.target === installModal || e.target.id === 'closeInstallModal') {
            clearTimeout(hideTimeout);
            hideSilentModeWarning();
          }
        });
      }
      
      sessionStorage.setItem('silentWarningShown', 'true');
    }
    
    function hideSilentModeWarning() {
      const warning = document.getElementById('silentModeWarning');
      if (warning) {
        warning.classList.add('hidden');
      }
    }
    
    // Основные функции приложения
    function loadResources() {
      // Загрузка прелоада с отложенным стартом
      const presplash = document.getElementById('presplash');
      if (presplash && presplash.dataset.src) {
        const img = new Image();
        img.src = presplash.dataset.src;
        img.onload = () => {
          presplash.src = img.src;
        };
      }
      
      // Динамическая загрузка скриптов
      const loadScript = (src) => {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = src;
          script.defer = true;
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      };
      
      Promise.all([
        loadScript('renpy-pre.js'),
        loadScript('renpy.js')
      ]).then(() => {
        // После загрузки Ren'Py патчим аудио функции
        setTimeout(patchRenpyAudio, 1000);
      }).catch(error => {
        console.error('Ошибка загрузки скриптов:', error);
      });
    }
    
    function hideLoader() {
      const loader = document.querySelector('.loader');
      if (loader) {
        loader.style.opacity = '0';
        setTimeout(() => {
          loader.style.display = 'none';
        }, 300);
      }
    }
    
    function setupContextMenu() {
      const contextButton = document.getElementById('ContextButton');
      const contextMenu = document.getElementById('ContextMenu');
      
      openContextMenu = () => {
        contextMenu.classList.add('visible');
        // Добавляем обработчик для закрытия при клике вне меню
        document.addEventListener('click', closeMenuOnClickOutside);
      };
      
      closeContextMenu = () => {
        contextMenu.classList.remove('visible');
        // Убираем обработчик при закрытии меню
        document.removeEventListener('click', closeMenuOnClickOutside);
      };
      
      // Функция для закрытия меню при клике вне его
      function closeMenuOnClickOutside(e) {
        // Проверяем, был ли клик вне меню и не по кнопке меню
        if (!contextMenu.contains(e.target) && e.target !== contextButton) {
          closeContextMenu();
        }
      }
      
      const toggleContextMenu = () => {
        if (contextMenu.classList.contains('visible')) {
          closeContextMenu();
        } else {
          openContextMenu();
        }
      };
      
      contextButton.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleContextMenu();
      });
      
      // Закрытие меню при выборе пунктов
      const contextItems = document.querySelectorAll('.context-menu-item');
      contextItems.forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          closeContextMenu();
        });
      });
      
      // Обработка импорта сохранений
      const importButton = document.getElementById('ID_SavegamesImport');
      if (importButton) {
        importButton.addEventListener('change', function() {
          closeContextMenu();
          onSavegamesImport(this);
        });
      }
    }
    
    function setupFullscreen() {
      const fullscreenButton = document.getElementById('FullscreenButton');
      const fullscreenIcon = document.getElementById('FullscreenIcon');
      if (!fullscreenButton || !fullscreenIcon) return;
      
      // Проверяем, является ли устройство iOS
      const isIOSDevice = isIOS();
      
      // Скрываем кнопку полноэкранного режима на iOS
      if (isIOSDevice) {
        fullscreenButton.style.display = 'none';
        return;
      }
      
      // Функция переключения полноэкранного режима
      const toggleFullscreen = () => {
        if (!document.fullscreenElement && 
            !document.webkitFullscreenElement && 
            !document.mozFullScreenElement && 
            !document.msFullscreenElement) {
          const element = document.documentElement;
          if (element.requestFullscreen) {
            element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      };
      
      // Обновление иконки при изменении состояния
      const updateFullscreenIcon = () => {
        const isFullscreen = document.fullscreenElement || 
                           document.webkitFullscreenElement ||
                           document.mozFullScreenElement ||
                           document.msFullscreenElement;
        
        // Переключаем иконку (используем PNG)
        fullscreenIcon.src = isFullscreen ? 
          'icons/unfullscreen.png' : 
          'icons/fullscreen.png';
        
        // Обновляем подсказку
        fullscreenButton.setAttribute(
          'aria-label', 
          isFullscreen ? 'Выйти из полноэкранного режима' : 'Полноэкранный режим'
        );
      };
      
      // Обработчик клика по кнопке
      fullscreenButton.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFullscreen();
      });
      
      // Обновление иконки при изменении состояния
      document.addEventListener('fullscreenchange', updateFullscreenIcon);
      document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
      document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
      document.addEventListener('MSFullscreenChange', updateFullscreenIcon);
      
      // Инициализация иконки
      updateFullscreenIcon();
    }
    
    function setupInstallPrompt() {
      const installMenuItem = document.getElementById('installMenuItem');
      const installModal = document.getElementById('installModal');
      const closeInstallModal = document.getElementById('closeInstallModal');
      
      if (!installMenuItem || !installModal) return;
      
      // Проверяем, является ли устройство iOS
      const isIOSDevice = isIOS();
      
      // Проверяем, не установлено ли уже приложение
      const isStandalone = isRunningInStandaloneMode();
      
      // Показываем пункт меню установки только на iOS и если приложение еще не установлено
      if (isIOSDevice && !isStandalone) {
        installMenuItem.style.display = 'flex';
      } else {
        installMenuItem.style.display = 'none';
      }
      
      // Функция показа инструкций
      const showInstallInstructions = () => {
        installModal.classList.add('visible');
      };
      
      // Функция скрытия инструкций
      const hideInstallInstructions = () => {
        installModal.classList.remove('visible');
      };
      
      // Обработчик клика по пункту меню
      installMenuItem.addEventListener('click', (e) => {
        e.stopPropagation();
        closeContextMenu();
        showInstallInstructions();
      });
      
      closeInstallModal.addEventListener('click', hideInstallInstructions);
      
      // Закрытие модального окна при клике вне его
      installModal.addEventListener('click', (e) => {
        if (e.target === installModal) {
          hideInstallInstructions();
        }
      });
    }
    
    function setupIOSBehavior() {
      const isIOSDevice = isIOS();
      const isStandalone = isRunningInStandaloneMode();
      
      // Если это iOS и приложение запущено с домашнего экрана
      if (isIOSDevice && isStandalone) {
        // Скрываем все элементы интерфейса
        const contextContainer = document.getElementById('ContextContainer');
        const topRightContainer = document.getElementById('TopRightContainer');
        
        if (contextContainer) contextContainer.style.display = 'none';
        if (topRightContainer) topRightContainer.style.display = 'none';
        
        // Убедимся, что игра занимает весь экран
        document.body.style.margin = '0';
        document.body.style.padding = '0';
        document.body.style.overflow = 'hidden';
      }
    }
    
    function setupIOSFix() {
      if (!isIOS()) return;
      
      const canvas = document.getElementById('canvas');
      if (!canvas) return;
      
      // Установка правильных размеров body для iOS standalone
      document.documentElement.style.height = '100%';
      document.documentElement.style.width = '100%';
      document.body.style.height = '100%';
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';
      document.body.style.position = 'fixed';
      document.body.style.margin = '0';
      document.body.style.padding = 'env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)';
      
      // Добавляем класс для CSS-фиксации
      document.body.classList.add('ios-standalone');
      
      // Фикс для безопасных областей на iPhone X+
      const viewport = document.querySelector('meta[name="viewport"]');
      if (viewport) {
        viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
      }
      
      // Сохраняем оригинальные размеры canvas для восстановления
      let originalWidth = canvas.width;
      let originalHeight = canvas.height;
      
      // Улучшенный обработчик изменения ориентации
      let orientationChangeTimeout;
      function handleOrientationChange() {
        clearTimeout(orientationChangeTimeout);
        
        // Сохраняем текущее состояние
        const wasHidden = document.hidden;
        
        // Используем setTimeout для ожидания завершения анимации поворота
        setTimeout(() => {
          // Проверяем, что страница видима и не скрыта
          if (document.hidden || wasHidden) return;
          
          // Корректно определяем размеры с учетом безопасных областей
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          // Проверяем, что размеры изменились (избегаем ложных срабатываний)
          if (Math.abs(canvas.width - width * window.devicePixelRatio) > 1 || 
              Math.abs(canvas.height - height * window.devicePixelRatio) > 1) {
            
            // Устанавливаем правильные размеры canvas
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            
            // Обновляем стили
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            
            // Сохраняем новые оригинальные размеры
            originalWidth = canvas.width;
            originalHeight = canvas.height;
            
            // Вызываем обработчик изменения размера в Ren'Py
            if (typeof Module !== 'undefined' && Module.onResize) {
              Module.onResize();
            }
            
            // Принудительно перерисовываем сцену
            if (typeof Module !== 'undefined' && Module._repaint) {
              Module._repaint();
            }
            
            // Принудительно фокусируемся на canvas
            canvas.focus();
          }
        }, 200); // Увеличенная задержка для iOS
        
        // Дополнительная проверка через большее время
        orientationChangeTimeout = setTimeout(() => {
          // Проверяем, что страница видима
          if (!document.hidden) {
            // Дополнительная проверка и коррекция размеров
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            if (Math.abs(canvas.width - width * window.devicePixelRatio) > 5 || 
                Math.abs(canvas.height - height * window.devicePixelRatio) > 5) {
              
              canvas.width = width * window.devicePixelRatio;
              canvas.height = height * window.devicePixelRatio;
              canvas.style.width = `${width}px`;
              canvas.style.height = `${height}px`;
              
              if (typeof Module !== 'undefined' && Module.onResize) {
                Module.onResize();
              }
              
              if (typeof Module !== 'undefined' && Module._repaint) {
                Module._repaint();
              }
            }
          }
        }, 500);
      }
      
      // Более надежные обработчики для iOS
      window.addEventListener('orientationchange', handleOrientationChange);
      window.addEventListener('resize', handleOrientationChange);
      
      // Улучшенные обработчики для восстановления после паузы
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          // Даем время системе обновить размеры
          setTimeout(handleOrientationChange, 150);
        }
      });
      
      // Обработчик для pageshow с повышенной надежностью
      window.addEventListener('pageshow', (event) => {
        if (event.persisted || document.hidden === false) {
          setTimeout(handleOrientationChange, 200);
          
          // Принудительное восстановление состояния canvas
          setTimeout(() => {
            if (canvas && typeof Module !== 'undefined' && Module._repaint) {
              Module._repaint();
            }
          }, 400);
        }
      });
      
      // Дополнительные обработчики для iOS
      document.addEventListener('webkitvisibilitychange', () => {
        if (!document.webkitHidden) {
          setTimeout(handleOrientationChange, 150);
        }
      });
      
      // Обработчик для событий приложения (iOS)
      document.addEventListener('resume', () => {
        setTimeout(handleOrientationChange, 200);
      }, false);
      
      // Фикс для touch-событий
      let lastTouchTime = 0;
      canvas.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (now - lastTouchTime < 300) return;
        lastTouchTime = now;
        
        const clickEvent = new MouseEvent('click', {
          view: window,
          bubbles: true,
          cancelable: true
        });
        e.target.dispatchEvent(clickEvent);
      }, { passive: true });
      
      // Принудительная инициализация размеров при старте
      setTimeout(() => {
        handleOrientationChange();
        
        // Дополнительная проверка через 1 секунду
        setTimeout(handleOrientationChange, 1000);
      }, 100);
    }
    
    // Автоматическое открытие меню на iOS при загрузке
    function autoOpenMenuOnIOS() {
      const isIOSDevice = isIOS();
      const isStandalone = isRunningInStandaloneMode();
      
      // Открываем меню автоматически на iOS, если не в standalone режиме
      if (isIOSDevice && !isStandalone && typeof openContextMenu === 'function') {
        setTimeout(() => {
          openContextMenu();
        }, 1000);
      }
    }
    
    // Обработчики для управления аудио
    function setupAudioHandlers() {
      // Добавляем обработчики для первого пользовательского взаимодействия
      document.addEventListener('click', handleFirstUserInteraction);
      document.addEventListener('touchstart', handleFirstUserInteraction);
      document.addEventListener('keydown', handleFirstUserInteraction);
      
      // Обработчик изменения видимости страницы
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          pauseAllAudio();
        } else if (userInteracted) {
          resumeAllAudio();
        }
      });
      
      // Обработчик перед закрытием страницы
      window.addEventListener('beforeunload', () => {
        pauseAllAudio();
      });
      
      // Обработчик для Android Chrome - приостанавливаем аудио при сворачивании
      if (isAndroid()) {
        document.addEventListener('pause', pauseAllAudio, false);
        document.addEventListener('resume', () => {
          if (userInteracted) {
            resumeAllAudio();
          }
        }, false);
      }
    }
    
    // Инициализация приложения
    function init() {
      loadResources();
      setupContextMenu();
      setupFullscreen();
      setupInstallPrompt();
      setupIOSFix();
      setupIOSBehavior();
      setupAudioHandlers();
      autoOpenMenuOnIOS(); // Автоматическое открытие меню на iOS
      
      // Показываем предупреждение о беззвучном режиме на iOS
      if (isIOS()) {
        showSilentModeWarning();
      }
      
      // Обработчики событий
      window.addEventListener('load', hideLoader);
      window.addEventListener('error', hideLoader);
    }
    
    // Запуск приложения после загрузки DOM
    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>